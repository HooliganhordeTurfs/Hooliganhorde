import { Source } from "graphql";
import { sum } from "lodash";
import { Token } from "src/classes/Token";
import { TokenValue } from "src/TokenValue";
import { getTestUtils } from "src/utils/TestUtils/provider";
import { DataSource } from "../HooliganhordeSDK";
import { Convert } from "./Convert";

const { sdk, account, utils } = getTestUtils();

jest.setTimeout(30000);

describe("Firm Convert", function () {
  const convert = new Convert(sdk);
  const HOOLIGAN = sdk.tokens.HOOLIGAN;
  const HOOLIGANLP = sdk.tokens.HOOLIGAN_CRV3_LP;
  const urHOOLIGAN = sdk.tokens.UNRIPE_HOOLIGAN;
  const urHOOLIGANLP = sdk.tokens.UNRIPE_HOOLIGAN_CRV3;
  const whitelistedTokens = [HOOLIGAN, HOOLIGANLP, urHOOLIGAN, urHOOLIGANLP];

  beforeAll(async () => {
    await utils.resetFork();
    // set default state as p > 1
    await utils.setCurveLiquidity(10_000_000, 15_000_000);
  });

  it("Validates tokens", async () => {
    const a = async () => {
      await convert.convert(sdk.tokens.USDC, HOOLIGANLP, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const b = async () => {
      await convert.convert(HOOLIGAN, sdk.tokens.USDC, TokenValue.ONE);
      throw new Error("fromToken is nost whitelisted");
    };
    const c = async () => {
      await convert.convert(HOOLIGAN, HOOLIGAN, TokenValue.ONE);
      throw new Error("Cannot convert between the same token");
    };
    await expect(a).rejects.toThrowError("fromToken is not whitelisted");
    await expect(b).rejects.toThrowError("toToken is not whitelisted");
    await expect(c).rejects.toThrowError("Cannot convert between the same token");
  });

  it("Validates amount", async () => {
    await utils.setHOOLIGANBalance(account, TokenValue.ZERO);
    const a = async () => {
      await convert.convert(HOOLIGAN, HOOLIGANLP, HOOLIGAN.amount(500));
    };

    await expect(a).rejects.toThrowError("Insufficient balance");
  });

  it("Calculates crates when toToken is LP", async () => {
    const currentGameday = 10_000;
    const c1 = utils.mockDepositCrate(HOOLIGAN, 9000, "500", currentGameday);
    const c2 = utils.mockDepositCrate(HOOLIGAN, 9001, "300", currentGameday);
    const c3 = utils.mockDepositCrate(HOOLIGAN, 9002, "100", currentGameday);

    // random order
    const crates = [c3, c1, c2];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by gameday
    const calc1 = convert.calculateConvert(HOOLIGAN, HOOLIGANLP, HOOLIGAN.amount(850), crates, currentGameday);
    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("500"); // takes full amount from c1
    expect(calc1.crates[0].gameday.toString()).toEqual("9000"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("300"); // takes full amount from c2
    expect(calc1.crates[1].gameday.toString()).toEqual("9001"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("50"); // takes 300 from c3
    expect(calc1.crates[2].gameday.toString()).toEqual("9002"); // confirm this is c3
    expect(calc1.prospects.toHuman()).toEqual("1700");
    expect(calc1.horde.toHuman()).toEqual("1019.92");

    // ensure it pulls one crate
    // crate should be sorted ASC by gameday
    const calc2 = convert.calculateConvert(HOOLIGAN, HOOLIGANLP, HOOLIGAN.amount(400), crates, currentGameday);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("400"); // takes full amount from c1
    expect(calc1.crates[0].gameday.toString()).toEqual("9000"); // confirm this is c3
    expect(calc2.prospects.toHuman()).toEqual("800");
    expect(calc2.horde.toHuman()).toEqual("480");
  });

  it("Calculates crates when toToken is NOT LP", async () => {
    const currentGameday = 10393;
    // the bdv generated by the mock is exactly the same as the amount
    // but we need them to be slightly different for sorting to be noticeable
    const c1 = utils.mockDepositCrate(HOOLIGANLP, 10100, "2000", currentGameday);
    c1.bdv = TokenValue.fromHuman(2123, 6);
    // ratio: 2123/2000 = 1.0615

    const c2 = utils.mockDepositCrate(HOOLIGANLP, 10101, "1000", currentGameday);
    c2.bdv = TokenValue.fromHuman(1234, 6);
    // ratio: 1234/1000 = 1.234

    const c3 = utils.mockDepositCrate(HOOLIGANLP, 10102, "500", currentGameday);
    c3.bdv = TokenValue.fromHuman(534, 6);
    // ratio: 534/500 = 1.068

    // random order
    const crates = [c2, c1, c3];

    // ensure it picks across multiple crates
    // crates should be sorted ASC by BDVRatio
    const calc1 = convert.calculateConvert(HOOLIGANLP, HOOLIGAN, HOOLIGANLP.amount(3000), crates, currentGameday);

    expect(calc1.crates.length).toEqual(3);
    expect(calc1.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].gameday.toString()).toEqual("10100"); // confirm this is c1
    expect(calc1.crates[1].amount.toHuman()).toEqual("500"); // takes full amount from c2
    expect(calc1.crates[1].gameday.toString()).toEqual("10102"); // confirm this is c2
    expect(calc1.crates[2].amount.toHuman()).toEqual("500"); // takes 300 from c3
    expect(calc1.crates[2].gameday.toString()).toEqual("10101"); // confirm this is c3
    expect(calc1.prospects.toHuman()).toEqual("13096");
    expect(calc1.horde.toHuman()).toEqual("3625");

    // ensure it pulls one crate
    // crate should be sorted ASC by gameday
    const calc2 = convert.calculateConvert(HOOLIGAN, HOOLIGANLP, HOOLIGAN.amount(2000), crates, currentGameday);
    expect(calc2.crates.length).toEqual(1);
    expect(calc2.crates[0].amount.toHuman()).toEqual("2000"); // takes full amount from c1
    expect(calc1.crates[0].gameday.toString()).toEqual("10100"); // confirm this is c3
    expect(calc2.prospects.toHuman()).toEqual("4246");
    expect(calc2.horde.toHuman()).toEqual("2357.4");
  });

  describe.each([
    { from: HOOLIGAN, to: HOOLIGAN },
    { from: HOOLIGANLP, to: HOOLIGANLP },
    { from: urHOOLIGAN, to: urHOOLIGAN },
    { from: urHOOLIGANLP, to: urHOOLIGANLP }
  ])("Convert to self fails", (pair) => {
    const { from, to } = pair;

    it(`Convert ${from.symbol} -> ${to.symbol}`, async () => {
      const fn = async () => sdk.firm.convert(from, to, from.amount(1));
      await expect(fn).rejects.toThrowError("Cannot convert between the same token");
    });
  });

  describe("With balance", () => {
    beforeAll(async () => {
      await deposit(HOOLIGAN, HOOLIGAN, 500);
      await deposit(HOOLIGANLP, HOOLIGANLP, 500);
      await deposit(urHOOLIGAN, urHOOLIGAN, 500);
      await deposit(urHOOLIGANLP, urHOOLIGANLP, 500);
    });

    describe.each([
      { from: HOOLIGAN, to: urHOOLIGAN },
      { from: HOOLIGAN, to: urHOOLIGANLP },

      { from: HOOLIGANLP, to: urHOOLIGAN },
      { from: HOOLIGANLP, to: urHOOLIGANLP },

      { from: urHOOLIGAN, to: HOOLIGAN },
      { from: urHOOLIGAN, to: HOOLIGANLP },

      { from: urHOOLIGANLP, to: HOOLIGAN },
      { from: urHOOLIGANLP, to: HOOLIGANLP }
    ])("Unsupported paths", (pair) => {
      const { from, to } = pair;

      it(`Fail ${from.symbol} -> ${to.symbol}`, async () => {
        const fn = async () => sdk.firm.convert(from, to, from.amount(1));
        await expect(fn).rejects.toThrowError("Cannot convert between these tokens");
      });
    });

    describe("DeltaB < 0", () => {
      beforeAll(async () => {
        // Force deltaB < 0
        await utils.setCurveLiquidity(15_000_000, 10_000_000);
      });

      describe.each([
        { from: HOOLIGANLP, to: HOOLIGAN },
        { from: urHOOLIGANLP, to: urHOOLIGAN }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const { deposited: balanceBefore } = await sdk.firm.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.firm.convertEstimate(from, to, from.amount(100));
          await sdk.firm.convert(from, to, from.amount(100));
          const { deposited: balanceAfter } = await sdk.firm.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: HOOLIGAN, to: HOOLIGANLP },
        { from: urHOOLIGAN, to: urHOOLIGANLP }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.firm.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is < 0");
        });
      });
    });

    describe("DeltaB > 0", () => {
      beforeAll(async () => {
        // Force deltaB > 0
        await utils.setCurveLiquidity(10_000_000, 15_000_000);
      });

      describe.each([
        { from: HOOLIGAN, to: HOOLIGANLP },
        { from: urHOOLIGAN, to: urHOOLIGANLP }
      ])("Converts Successfully", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const { deposited: balanceBefore } = await sdk.firm.getBalance(to, account, { source: DataSource.LEDGER });
          const { minAmountOut } = await sdk.firm.convertEstimate(from, to, from.amount(100));
          await sdk.firm.convert(from, to, from.amount(100));
          const { deposited: balanceAfter } = await sdk.firm.getBalance(to, account, { source: DataSource.LEDGER });

          expect(balanceAfter.amount.gte(balanceBefore.amount.add(minAmountOut))).toBe(true);
        });
      });

      describe.each([
        { from: HOOLIGANLP, to: HOOLIGAN },
        { from: urHOOLIGANLP, to: urHOOLIGAN }
      ])("Errors correctly", (pair) => {
        const { from, to } = pair;

        it(`${from.symbol} -> ${to.symbol}`, async () => {
          const fn = async () => await sdk.firm.convert(from, to, from.amount(100));

          await expect(fn).rejects.toThrowError("Cannot convert this token when deltaB is >= 0");
        });
      });
    });
  });
});

async function deposit(from: Token, to: Token, _amount: number) {
  const amount = from.amount(_amount);
  await utils.setBalance(from, account, amount);
  await from.approveHooliganhorde(amount);
  const txr = await sdk.firm.deposit(from, to, amount);
  await txr.wait();
}
